<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pokémon Card Viewer</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
     <!-- Navbar injectée -->
    <div id="navbar-container"></div>
    <script src="navbar.js"></script>

    <div class="header">
        <h1>Pokédex Interactif</h1>
        <p>Cliquez sur les cartes pour découvrir les détails</p>
    </div>

    <div class="controls">
        <div class="filter-group">
            <label for="tier-filter">Filtrer par Tier:</label>
            <select id="tier-filter">
                <option value="all">Tous les tiers</option>
                <option value="1">Tier 1</option>
                <option value="2">Tier 2</option>
                <option value="3">Tier 3</option>
                <option value="4">Tier 4</option>
                <option value="5">Tier 5</option>
                <option value="6">Tier 6</option>
                <option value="7">Tier 7</option>
                <option value="8">Tier 8</option>
                <option value="9">Tier 9</option>
            </select>
        </div>
    </div>

    <div id="content"></div>

    <script>
        const typeIcons = {
            "Normal": "/img/Icon/normal_icon.png",
            "Combat": "/img/Icon/combat_icon.png",
            "Vol": "/img/Icon/vol_icon.png",
            "Poison": "/img/Icon/poison_icon.png",
            "Sol": "/img/Icon/sol_icon.png",
            "Roche": "/img/Icon/roche_icon.png",
            "Insecte": "/img/Icon/insecte_icon.png",
            "Spectre": "/img/Icon/spectre_icon.png",
            "Acier": "/img/Icon/acier_icon.png",
            "Feu": "/img/Icon/feu_icon.png",
            "Eau": "/img/Icon/eau_icon.png",
            "Plante": "/img/Icon/plante_icon.png",
            "Electric": "/img/Icon/electric_icon.png",
            "Psy": "/img/Icon/psy_icon.png",
            "Glace": "/img/Icon/glace_icon.png",
            "Dragon": "/img/Icon/dragon_icon.png",
            "Ténèbres": "/img/Icon/tenebres_icon.png",
            "Fée": "/img/Icon/fee_icon.png"
        };

        function renderTypeIcons(arr) {
            if (!Array.isArray(arr) || arr.length === 0) return '—';
            return arr
                .filter(type => type && typeIcons[type])
                .map(type => `<img src="..${typeIcons[type]}" alt="${type}" title="${type}" style="width:24px; height:24px; vertical-align:middle;">`)
                .join(' ');
        }
        // Données d'exemple intégrées (remplace le fetch)
        const sampleData = [
            {
                "id": 1,
                "name": "Probleme de chargement",
                "image": "https://img.pokemondb.net/sprites/home/normal/2x/avif/scraggy.avif",
                "tier": 1,
                "hp": 1,
                "difficulty": "?",
                "armor": "?",
                "type": ["?"],
                "major_weakness": [""],
                "weakness": ["?"],
                "resistance": ["?"],
                "major_resistance": ["?"],
                "immunity": [""],
                "attacks": [""]
            }
        ];

        // VERSION CORRIGÉE DE TON CODE
        // VERSION CORRIGÉE DE TON CODE
        async function loadMonsters() {
            try {
                const res = await fetch('pokemon.json'); // <-- ton JSON simplifié
                if (!res.ok) throw new Error(`Erreur HTTP: ${res.status}`);
                
                let monsters = await res.json();

                // 🔑 Calcul automatique des faiblesses / résistances / immunités
                monsters = monsters.map(p => {
                    const computed = computeTypeChart(p);
                    return {
                        ...p,
                        ...computed
                    };
                });

                // 🔑 Si on est en local (localhost, 127.0.0.1 ou file://), forcer tout en "unlock"
                if (
                    location.hostname === "localhost" || 
                    location.hostname === "127.0.0.1" || 
                    location.protocol === "file:"
                ) {
                    monsters = monsters.map(p => ({ ...p, status: "unlock" }));
                    console.log("Mode local détecté → tous les Pokémon sont débloqués !");
                }

                initUI(monsters);

            } catch (err) {
                console.error('Erreur de chargement:', err);
                showError(`Impossible de charger pokemon.json: ${err.message}`);
                initUI(sampleData); // fallback
            }
        }

        let attaqueData = [];
        let passifData = [];
        let statusData = [];

        async function loadAttacks() {
            const res = await fetch('attaque.json');
            attaqueData = await res.json();
        }

        async function loadPassifs() {
            const res = await fetch('passifs.json');
            passifData = await res.json();
        }

        async function loadStatus() {
            const res = await fetch('status.json');
            statusData = await res.json();
        }

        function showError(message) {
            const content = document.getElementById('content');
            content.innerHTML = `<div class="error-message">${message}</div>`;
        }

        function initUI(monsters) {
            const content = document.getElementById('content');
            content.innerHTML = ''; // Nettoyer le contenu

            // Création des sections (Tier 1..9)
            const sectionsMap = new Map();
            for (let t = 1; t <= 9; t++) {
                const section = document.createElement('section');
                section.className = 'tier-section';
                section.dataset.tier = `${t}`;
                section.innerHTML = `
                    <div class="tier-header">
                        <h2>Tier ${t}</h2>
                        <div class="tier-note">Nombre: <span class="count">0</span></div>
                    </div>
                    <div class="cards-grid" aria-live="polite"></div>
                    <div class="empty-note" style="display:none">Aucun Pokémon dans ce tier</div>
                `;
                content.appendChild(section);
                sectionsMap.set(t, section);
            }

            // 1️⃣ Filtrer : on enlève les "hide"
            let validMonsters = monsters.filter(p => {
                if (p.status === "hide") return false;
                if (!p.name || !p.tier || p.tier < 1 || p.tier > 9) {
                    console.warn('Pokémon invalide ignoré:', p);
                    return false;
                }
                return true;
            });

            // 2️⃣ Trier par tier puis par id
            validMonsters.sort((a, b) => {
                if (a.tier !== b.tier) return a.tier - b.tier;
                return (a.id ?? 0) - (b.id ?? 0);
            });

            // 3️⃣ Remplir les sections
            validMonsters.forEach(p => {
                const section = sectionsMap.get(p.tier);
                if (section) {
                    const grid = section.querySelector('.cards-grid');
                    const card = createCard(p);
                    grid.appendChild(card);
                }
            });

            // 4️⃣ Mettre à jour compteurs et messages vides
            sectionsMap.forEach(section => {
                const countSpan = section.querySelector('.count');
                const grid = section.querySelector('.cards-grid');
                const emptyNote = section.querySelector('.empty-note');
                const count = grid.children.length;
                
                countSpan.textContent = count;
                emptyNote.style.display = count === 0 ? 'block' : 'none';
            });

            // Filtre
            setupFilter(sectionsMap);
        }


        function setupFilter(sectionsMap) {
            const filter = document.getElementById('tier-filter');
            filter.addEventListener('change', (e) => {
                const val = e.target.value;
                
                if (val === 'all') {
                    sectionsMap.forEach(section => {
                        section.style.display = '';
                    });
                } else {
                    const tierNum = parseInt(val);
                    sectionsMap.forEach((section, tier) => {
                        section.style.display = (tier === tierNum) ? '' : 'none';
                    });
                    
                    // Scroll vers la section choisie
                    const targetSection = sectionsMap.get(tierNum);
                    if (targetSection) {
                        targetSection.scrollIntoView({
                            behavior: 'smooth', 
                            block: 'start'
                        });
                    }
                }
            });
        }

        function setupAttackTooltips() {
            const tt1 = document.getElementById('attack-tooltip');
            const tt2 = document.getElementById('attack-tooltip2');
            let locked = false;
            let currentItem = null;

            function showTooltips(item) {
                // Tooltip 1 : attaque/passif
                tt1.innerHTML = `<strong>${item.textContent}</strong> - ${item.dataset.type || '—'}` +
                                " " +
                                (item._descHtml || '—');
                tt1.style.display = 'block';
                tt1.setAttribute('aria-hidden', 'false');

                // Tooltip 2 : highlights (status + passifs)
                const tmp = document.createElement('div');
                tmp.innerHTML = item._descHtml || '';
                const highlights = tmp.querySelectorAll('[data-status-name], [data-passifs-name]');

                const tooltip2Content = Array.from(highlights).map(span => {
                    if (span.dataset.statusName) {
                        const s = statusData.find(x => x.Nom === span.dataset.statusName);
                        return s ? `<strong>${s.Nom}</strong><div>${s.description}</div>` : null;
                    }
                    if (span.dataset.passifsName) {
                        const p = passifData.find(x => x.Nom === span.dataset.passifsName);
                        return p ? `<strong>${p.Nom}</strong><div>${p.description}</div>` : null;
                    }
                    return null;
                }).filter(Boolean).join('<hr>');

                tt2.innerHTML = tooltip2Content || '—';
                tt2.style.display = tooltip2Content ? 'block' : 'none';
                tt2.setAttribute('aria-hidden', tooltip2Content ? 'false' : 'true');

                currentItem = item;
            }

            document.addEventListener('mouseover', e => {
                const item = e.target.closest('.attack-item, .passif-item');
                if (!item) return;

                if (currentItem !== item) locked = false;
                if (!locked) showTooltips(item);
            });

            document.addEventListener('mousemove', e => {
                if (tt1.style.display === 'block' && !locked) {
                    tt1.style.left = e.pageX + 14 + 'px';
                    tt1.style.top  = e.pageY + 14 + 'px';
                }
                if (tt2.style.display === 'block' && !locked) {
                    const t1h = tt1.offsetHeight || 40;
                    tt2.style.left = e.pageX + 14 + 'px';
                    tt2.style.top  = e.pageY + 14 + t1h + 8 + 'px';
                }
            });

            document.addEventListener('mouseout', e => {
                if (locked) return;
                if (e.target.closest('.attack-item, .passif-item')) {
                    tt1.style.display = 'none';
                    tt2.style.display = 'none';
                    tt1.setAttribute('aria-hidden', 'true');
                    tt2.setAttribute('aria-hidden', 'true');
                    currentItem = null;
                }
            });

            document.addEventListener('click', e => {
                const item = e.target.closest('.attack-item, .passif-item');
                if (item) {
                    showTooltips(item);
                    locked = true;
                    currentItem = item;
                } else if (!e.target.closest('#attack-tooltip') && !e.target.closest('#attack-tooltip2')) {
                    locked = false;
                    tt1.style.display = 'none';
                    tt2.style.display = 'none';
                    tt1.setAttribute('aria-hidden', 'true');
                    tt2.setAttribute('aria-hidden', 'true');
                    currentItem = null;
                }
            });
        }

        function createCard(pokemon) {
            const card = document.createElement('div');
            card.className = 'card';
            card.tabIndex = 0;
            card.setAttribute('role', 'button');
            card.setAttribute('aria-pressed', 'false');

            const isSeen = pokemon.status === "seen";
            var cardStyle = "card-normie"
            if (pokemon.status === "seen") {
                card.style.filter = "grayscale(50%) brightness(0.7)";
                card.style.opacity = "0.85";
            }

            if (pokemon.alpha === "yes") {
                card.style.border = "2px solid #e74c3c"; // rouge
                card.style.boxShadow = "0 0 14px rgba(231, 76, 60, 0.8)";
                cardStyle = "card-alpha"
            } else {
                card.style.border = "2px solid #3498db"; // bleu par défaut
            }

            // Fallback image
            const imageUrl = pokemon.image || 'https://via.placeholder.com/120x120?text=?';

            // Helpers
            const showValue = (val) => isSeen ? '???' : (val ?? '—');
            const joinOrDash = (arr) => {
                if (!arr || !Array.isArray(arr)) return '—';
                const filtered = arr.filter(x => x && typeof x === 'string' && x.trim() !== '');
                return filtered.length > 0 ? (isSeen ? filtered.map(_ => '???').join(', ') : filtered.join(', ')) : '—';
            };

            // --- Carte HTML ---
            card.innerHTML = `
                <div class="card-inner">
                    <div class="card-front ${cardStyle}">
                        <img src="${imageUrl}" alt="${pokemon.name}" onerror="this.src='https://via.placeholder.com/120x120?text=?'">
                        <h3>${pokemon.name}</h3>
                        <p>Tier ${pokemon.tier}</p>
                    </div>


                    <div class="card-back ${cardStyle}">
                        <h3>${showValue(pokemon.name)}</h3>
                        <ul class="stats">
                            <li><strong>PV:</strong> ${showValue(pokemon.hp)}</li>
                            <li><strong>Esquive:</strong> ${showValue(pokemon.esquive)}</li>
                            <li><strong>Armure:</strong> ${showValue(pokemon.armor)}</li>
                            <li><strong>Type:</strong> ${renderTypeIcons(
                                                            Array.isArray(pokemon.type) 
                                                                ? pokemon.type.flatMap(t => t.split('/').map(x => x.trim())) 
                                                                : (pokemon.type ? pokemon.type.split('/').map(x => x.trim()) : [])
                                                        )}</li>
                        </ul>

                        ${pokemon.alpha === "yes" ? `
                        <h4>Points de rupture</h4>
                        <ul class="stats">
                            <li><strong>Face:</strong> ${pokemon.front ?? '—'}</li>
                            <li><strong>Côtés:</strong> ${pokemon.sides ?? '—'}</li>
                            <li><strong>Dos:</strong> ${pokemon.back ?? '—'}</li>
                        </ul>` : ''}

                        <h4>Attaques</h4>
                        <ul class="attacks"></ul>

                        <h4>Passifs</h4>
                        <ul class="passifs stats"></ul>
                        
                        <h4>Comportement</h4>
                        <p>${pokemon.comportement}</p>

                        <h4>Faiblesses / Résistances</h4>
                        <ul class="attacks">
                            <li><strong>Faiblesse majeure:</strong> ${renderTypeIcons(pokemon.major_weakness)}</li>
                            <li><strong>Faiblesses:</strong> ${renderTypeIcons(pokemon.weakness)}</li>
                            <li><strong>Résistances:</strong> ${renderTypeIcons(pokemon.resistance)}</li>
                            <li><strong>Résistances majeures:</strong> ${renderTypeIcons(pokemon.major_resistance)}</li>
                            <li><strong>Immunités:</strong> ${renderTypeIcons(pokemon.immunity)}</li>
                        </ul>
                    </div>
                </div>
            `;

            // --- Remplissage Attaques ---
            const attackList = card.querySelector('.attacks');
            if (pokemon.attacks && pokemon.attacks.length && !isSeen) {
                pokemon.attacks.forEach(a => {
                    const atk = attaqueData.find(atk => atk.Nom === a);
                    const li = document.createElement('li');
                    li.className = 'attack-item';

                    if (!atk) {
                        li.textContent = isSeen ? '???' : a;
                        attackList.appendChild(li);
                        return;
                    }

                    li.textContent = isSeen ? '???' : atk.Nom;
                    li.dataset.type = atk.type || '—';
                    li.dataset.range = atk.portée || '—';

                    // Conversion de la description en spans "highlight"
                    let desc = li.dataset.range + '<br>' + atk.description || '—';
                    desc = desc.replace(/\*\*(.*?)\*\*/g, (m, p1) => {
                        if (statusData.some(s => s.Nom === p1)) {
                            return `<span class="status-highlight" data-status-name="${p1}">${p1}</span>`;
                        }
                        if (passifData.some(p => p.Nom === p1)) {
                            return `<span class="passif-highlight" data-passifs-name="${p1}">${p1}</span>`;
                        }
                        return `<strong>${p1}</strong>`;
                    });

                    li._descHtml = desc;
                    attackList.appendChild(li);
                });
            } else {
                attackList.innerHTML = `<li>—</li>`;
            }

            // --- Remplissage Passifs ---
            const passifList = card.querySelector('.passifs');
            if (pokemon.passifs && pokemon.passifs.length && !isSeen) {
                pokemon.passifs.forEach(pName => {
                    const pas = passifData.find(p => p.Nom === pName);
                    const li = document.createElement('li');
                    li.className = 'passif-item';

                    if (!pas) {
                        li.textContent = isSeen ? '???' : pName;
                        passifList.appendChild(li);
                        return;
                    }

                    li.textContent = isSeen ? '???' : pas.Nom;

                    // Conversion en spans aussi
                    let desc = pas.description || '—';
                    desc = desc.replace(/\*\*(.*?)\*\*/g, (m, p1) => {
                        if (statusData.some(s => s.Nom === p1)) {
                            return `<span class="status-highlight" data-status-name="${p1}">${p1}</span>`;
                        }
                        if (passifData.some(p => p.Nom === p1)) {
                            return `<span class="passif-highlight" data-passifs-name="${p1}">${p1}</span>`;
                        }
                        return `<strong>${p1}</strong>`;
                    });

                    li._descHtml = desc;
                    passifList.appendChild(li);
                });
            } else {
                passifList.innerHTML = `<li>—</li>`;
            }

            // --- Flip ---
            if (pokemon.status === "unlock" || pokemon.status === "seen") {
                const toggleFlip = () => {
                    card.classList.toggle('is-flipped');
                    const pressed = card.classList.contains('is-flipped');
                    card.setAttribute('aria-pressed', pressed ? 'true' : 'false');
                };

                card.addEventListener('click', toggleFlip);
                card.addEventListener('keydown', (ev) => {
                    if (ev.key === 'Enter' || ev.key === ' ') {
                        ev.preventDefault();
                        toggleFlip();
                    }
                    if (ev.key === 'Escape') {
                        card.classList.remove('is-flipped');
                        card.setAttribute('aria-pressed', 'false');
                    }
                });
            }

            return card;
        }

        function renderKeywords(keywords) {
            if (!keywords) return '—';

            return keywords.split(',').map(word => {
                word = word.trim();
                // Vérifier si c'est un status
                if (statusData.some(s => s.Nom === word)) {
                    return `<span class="status-highlight" data-status-name="${word}">${word}</span>`;
                }
                // Vérifier si c'est un passif
                if (passifData.some(p => p.Nom === word)) {
                    return `<span class="status-highlight" data-passifs-name="${word}">${word}</span>`;
                }
                return word; // sinon texte brut
            }).join(', ');
        }


        // Table des interactions entre types
        // valeurs: 2 = faible (x2), 0.5 = résistant (½), 0 = immunité
        const typeChart = {
            "Normal":    { "Combat":2, "Spectre":0 },
            "Combat":    { "Vol":2, "Psy":2, "Fée":2, "Roche":0.5, "Insecte":0.5, "Ténèbres":0.5 },
            "Vol":       { "Roche":2, "Electric":2, "Glace":2, "Combat":0.5, "Plante":0.5, "Insecte":0.5 },
            "Poison":    { "Sol":2, "Psy":2, "Plante":0.5, "Combat":0.5, "Poison":0.5, "Insecte":0.5, "Fée":0.5 },
            "Sol":       { "Eau":2, "Plante":2, "Glace":2, "Poison":0.5, "Roche":0.5, "Electric":0 },
            "Roche":     { "Eau":2, "Plante":2, "Combat":2, "Sol":2, "Acier":2, "Feu":0.5, "Poison":0.5, "Normal":0.5, "Vol":0.5 },
            "Insecte":   { "Feu":2, "Vol":2, "Roche":2, "Combat":0.5, "Plante":0.5, "Sol":0.5 },
            "Spectre":   { "Spectre":2, "Ténèbres":2, "Normal":0, "Combat":0, "Poison":0.5, "Insecte":0.5 },
            "Acier":     { "Feu":2, "Combat":2, "Sol":2, "Psy":0.5, "Glace":0.5, "Roche":0.5, "Insecte":0.5, "Dragon":0.5, "Acier":0.5, "Normal":0.5, "Plante":0.5, "Fée":0.5, "Vol":0.5 },
            "Feu":       { "Eau":2, "Sol":2, "Roche":2, "Glace":0.5, "Plante":0.5, "Feu":0.5, "Insecte":0.5, "Acier":0.5, "Fée":0.5 },
            "Eau":       { "Electric":2, "Plante":2, "Feu":0.5, "Glace":0.5, "Eau":0.5, "Acier":0.5 },
            "Plante":    { "Feu":2, "Glace":2, "Poison":2, "Vol":2, "Insecte":2, "Eau":0.5, "Sol":0.5, "Plante":0.5, "Electric":0.5 },
            "Electric":  { "Sol":2, "Acier":0.5, "Electric":0.5, "Vol":0.5 },
            "Psy":       { "Insecte":2, "Spectre":2, "Ténèbres":2, "Combat":0.5, "Psy":0.5 },
            "Glace":     { "Feu":2, "Combat":2, "Roche":2, "Acier":2, "Glace":0.5 },
            "Dragon":    { "Glace":2, "Dragon":2, "Fée":2, "Eau":0.5, "Plante":0.5, "Feu":0.5, "Electric":0.5 },
            "Ténèbres":  { "Combat":2, "Insecte":2, "Fée":2, "Spectre":0.5, "Ténèbres":0.5 },
            "Fée":       { "Acier":2, "Poison":2, "Combat":0.5, "Insecte":0.5, "Ténèbres":0.5, "Dragon":0 },
        };

        // Fonction qui calcule les faiblesses/résistances/immunités
        function computeTypeChart(pokemon) {
            let types = [];
            if (Array.isArray(pokemon.type)) {
                // cas "Plante/Poison" => on split
                types = pokemon.type.flatMap(t => t.split('/'));
            } else if (typeof pokemon.type === "string") {
                types = pokemon.type.split('/');
            }

            const multipliers = {};

            // Appliquer les interactions pour chaque type du Pokémon
            types.forEach(t => {
                const interactions = typeChart[t] || {};
                Object.entries(interactions).forEach(([target, mult]) => {
                multipliers[target] = (multipliers[target] ?? 1) * mult;
                });
            });

            // Classer les résultats
            const weaknesses = [];
            const majorWeaknesses = [];
            const resistances = [];
            const majorResistances = [];
            const immunities = [];

            Object.entries(multipliers).forEach(([type, mult]) => {
                if (mult === 0) immunities.push(type);
                else if (mult == 2) weaknesses.push(type);
                else if (mult == 4) majorWeaknesses.push(type);
                else if (mult == 0.5) resistances.push(type);
                else if (mult == 0.25) majorResistances.push(type);
            });

            return {
                weakness: weaknesses,
                major_weakness : majorWeaknesses,
                resistance: resistances,
                major_resistance: majorResistances,
                immunity: immunities
            };
        }


        // Initialisation
        document.addEventListener('DOMContentLoaded', async ()=>{
            await loadAttacks();
            await loadPassifs();
            await loadStatus();
            await loadMonsters();
            setupAttackTooltips();
        });

    </script>
    <div id="attack-tooltip" class="tooltip" aria-hidden="true"></div>
    <div id="attack-tooltip2" class="tooltip" aria-hidden="true"></div>
</body>
</html>